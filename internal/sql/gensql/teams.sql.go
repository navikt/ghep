// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: teams.sql

package gensql

import (
	"context"
)

const addTeamMember = `-- name: AddTeamMember :exec
INSERT INTO team_members (team_slug, user_login) VALUES ($1, $2)
ON CONFLICT (team_slug, user_login) DO NOTHING
`

type AddTeamMemberParams struct {
	TeamSlug  string
	UserLogin string
}

func (q *Queries) AddTeamMember(ctx context.Context, arg AddTeamMemberParams) error {
	_, err := q.db.Exec(ctx, addTeamMember, arg.TeamSlug, arg.UserLogin)
	return err
}

const addTeamRepository = `-- name: AddTeamRepository :exec
INSERT INTO team_repositories (team_slug, repository_id) VALUES ($1, $2)
ON CONFLICT (team_slug, repository_id) DO NOTHING
`

type AddTeamRepositoryParams struct {
	TeamSlug     string
	RepositoryID int32
}

func (q *Queries) AddTeamRepository(ctx context.Context, arg AddTeamRepositoryParams) error {
	_, err := q.db.Exec(ctx, addTeamRepository, arg.TeamSlug, arg.RepositoryID)
	return err
}

const createTeam = `-- name: CreateTeam :exec
INSERT INTO teams (slug) VALUES ($1)
ON CONFLICT (slug) DO NOTHING
`

func (q *Queries) CreateTeam(ctx context.Context, slug string) error {
	_, err := q.db.Exec(ctx, createTeam, slug)
	return err
}

const getTeam = `-- name: GetTeam :one
SELECT slug FROM teams WHERE slug = $1
`

func (q *Queries) GetTeam(ctx context.Context, slug string) (string, error) {
	row := q.db.QueryRow(ctx, getTeam, slug)
	err := row.Scan(&slug)
	return slug, err
}

const getTeamMember = `-- name: GetTeamMember :one
SELECT user_login FROM team_members WHERE team_slug = $1 AND user_login = $2
`

type GetTeamMemberParams struct {
	TeamSlug  string
	UserLogin string
}

func (q *Queries) GetTeamMember(ctx context.Context, arg GetTeamMemberParams) (string, error) {
	row := q.db.QueryRow(ctx, getTeamMember, arg.TeamSlug, arg.UserLogin)
	var user_login string
	err := row.Scan(&user_login)
	return user_login, err
}

const getTeamMemberByEmail = `-- name: GetTeamMemberByEmail :one
SELECT tm.user_login
FROM team_members tm
JOIN emails e ON tm.user_login = e.login
WHERE tm.team_slug = $1 AND e.email = $2
`

type GetTeamMemberByEmailParams struct {
	TeamSlug string
	Email    string
}

func (q *Queries) GetTeamMemberByEmail(ctx context.Context, arg GetTeamMemberByEmailParams) (string, error) {
	row := q.db.QueryRow(ctx, getTeamMemberByEmail, arg.TeamSlug, arg.Email)
	var user_login string
	err := row.Scan(&user_login)
	return user_login, err
}

const getTeamMembersWithEmails = `-- name: GetTeamMembersWithEmails :many
SELECT tm.user_login, e.email
FROM team_members tm
JOIN emails e ON tm.user_login = e.login
WHERE tm.team_slug = $1
ORDER BY tm.user_login
`

type GetTeamMembersWithEmailsRow struct {
	UserLogin string
	Email     string
}

func (q *Queries) GetTeamMembersWithEmails(ctx context.Context, teamSlug string) ([]GetTeamMembersWithEmailsRow, error) {
	rows, err := q.db.Query(ctx, getTeamMembersWithEmails, teamSlug)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTeamMembersWithEmailsRow
	for rows.Next() {
		var i GetTeamMembersWithEmailsRow
		if err := rows.Scan(&i.UserLogin, &i.Email); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTeamMembers = `-- name: ListTeamMembers :many
SELECT user_login FROM team_members WHERE team_slug = $1 ORDER BY user_login
`

func (q *Queries) ListTeamMembers(ctx context.Context, teamSlug string) ([]string, error) {
	rows, err := q.db.Query(ctx, listTeamMembers, teamSlug)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var user_login string
		if err := rows.Scan(&user_login); err != nil {
			return nil, err
		}
		items = append(items, user_login)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTeamRepositories = `-- name: ListTeamRepositories :many
SELECT r.id, r.name
FROM team_repositories tr
JOIN repositories r ON tr.repository_id = r.id
WHERE tr.team_slug = $1
ORDER BY r.name
`

func (q *Queries) ListTeamRepositories(ctx context.Context, teamSlug string) ([]Repository, error) {
	rows, err := q.db.Query(ctx, listTeamRepositories, teamSlug)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Repository
	for rows.Next() {
		var i Repository
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTeams = `-- name: ListTeams :many
SELECT slug FROM teams ORDER BY slug
`

func (q *Queries) ListTeams(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, listTeams)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var slug string
		if err := rows.Scan(&slug); err != nil {
			return nil, err
		}
		items = append(items, slug)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTeamsByRepository = `-- name: ListTeamsByRepository :many
SELECT t.slug
FROM teams t
JOIN team_repositories tr ON t.slug = tr.team_slug
JOIN repositories r ON tr.repository_id = r.id
WHERE r.name = $1
ORDER BY t.slug
`

func (q *Queries) ListTeamsByRepository(ctx context.Context, name string) ([]string, error) {
	rows, err := q.db.Query(ctx, listTeamsByRepository, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var slug string
		if err := rows.Scan(&slug); err != nil {
			return nil, err
		}
		items = append(items, slug)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeTeamMember = `-- name: RemoveTeamMember :exec
DELETE FROM team_members WHERE team_slug = $1 AND user_login = $2
`

type RemoveTeamMemberParams struct {
	TeamSlug  string
	UserLogin string
}

func (q *Queries) RemoveTeamMember(ctx context.Context, arg RemoveTeamMemberParams) error {
	_, err := q.db.Exec(ctx, removeTeamMember, arg.TeamSlug, arg.UserLogin)
	return err
}

const removeTeamRepository = `-- name: RemoveTeamRepository :exec
DELETE FROM team_repositories
WHERE team_slug = $1 AND repository_id = (SELECT id FROM repositories WHERE name = $2)
`

type RemoveTeamRepositoryParams struct {
	TeamSlug string
	Name     string
}

func (q *Queries) RemoveTeamRepository(ctx context.Context, arg RemoveTeamRepositoryParams) error {
	_, err := q.db.Exec(ctx, removeTeamRepository, arg.TeamSlug, arg.Name)
	return err
}
